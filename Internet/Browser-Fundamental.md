# 브라우저 동작 원리

## 1. 브라우저란?

브라우저 또는 웹 브라우저는 웹 서버에서 이동하며 쌍방향으로 통신하고 HTML 문서나 그림, 멀티미디어 파일을 출력하는 월드 와이드 웹(WWW)을 기반으로 한 응용 소프트웨어이다.

웹 브라우저는 대표적인 HTTP 사용자 에이전트의 하나이기도 하다. 주요 웹 브라우저는 파이어폭스(모질라), 크롬(구글), 인터넷 익스플로러/마이크로소프트 엣지(마이크로 소프트), 오페라, 사파리 등이 있다.

## 2. 브라우저의 주요 기능

브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

💡 **여기서 URI란?**
'통합 자원 식별자'라는 뜻으로, 인터넷에 있는 자원을 나타내는 유일한 주소이다. URI의 존재는 인터넷에서 요구되는 기본 조건으로서 인터넷 프로토콜에 항상 붙어 다닌다. URI의 하위 개념으로 URL, URN이 있다.

브라우저는 HTML과 CSS 명세에 따라 HTML 파일을 해석해서 표시하는데 이 명세는 웹 표준화 기구인 W3C(World Wide Web Consortium)에서 정한다. 과거에는 브라우저들이 일부만 이 명세에 따라 구현하고 독자적인 방법으로 확장함으로써 웹 제작자가 심각한 호환성 문제를 겪었지만 최근에는 대부분의 브라우저가 표준 명세를 따른다.

브라우저의 사용자 인터페이스는 서로 닮아 있는데, 다음과 같은 요소들이 일반적이다.

- URI를 입력할 수 있는 주소 표시 줄
- 이전 버튼과 다음 버튼
- 북마크
- 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼
- 홈버튼

브라우저의 사용자 인터페이스는 표준 명세가 없음에도 불구하고 수 년간 서로의 장점을 모방하면서 현재에 이르게 되었다. HTML5 명세는 주소 표시줄, 상태 표시줄, 도구 모음과 같은 일반적인 요소를 제외하고 브라우저의 필수 UI를 정의하지 않았다. 물론 파이어폭스의 다운로드 관리자와 같이 브라우저에 특화된 기능도 있다.

## 3. 브라우저의 기본 구조

![browser-structure](https://user-images.githubusercontent.com/65386533/110413428-2b6cc180-80d1-11eb-84e8-da1247bf0d0d.png)

▲ 브라우저의 주요 구성 요소

브라우저의 주요 구성 요소는 위와 같다.

1. 사용자 인터페이스 : 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분.
2. 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
3. 렌더링 엔진 : 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시.
4. 통신 : HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
5. UI 백엔드 : 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
6. 자바스크립트 해석기 : 자바스크립트 코드를 해석하고 실행.
7. 자료 저장소 : 이 부분은 자료를 저장하는 계층으로, 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.

💡 크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지하는 것이 주목할 만하다. 각 탭은 독립적인 프로세스로 처리된다.

## 4. 렌더링 엔진

렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일이다.

렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다.

### 4.1 렌더링 엔진들

파이어폭스와 크롬, 사파리는 두 종류의 렌더링 엔진으로 제작되었다. 파이어폭스는 모질라에서 직접 만든 게코(Gecko) 엔진을 사용 하고 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.

웹킷은 최초 리눅스 플랫폼에서 동작하기 위해 제작된 오픈 소스 엔진인데 애플이 맥과 윈도우즈에서 사파리 브라우저를 지원하기 위해 수정을 가했다.

### 4.2 동작 과정

렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.

![rendering-process](https://user-images.githubusercontent.com/65386533/110413438-2dcf1b80-80d1-11eb-9553-029af980c3e5.png)

▲ 렌더링 엔진의 동작 과정

1. 렌더링 엔진은 HTML 문서를 파싱하고 "콘텐츠 트리" 내부에서 태그를 DOM 노드로 변환한다. 그 다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다.
2. 스타일 정보와 HTML 표시 규칙은 "렌더 트리"라고 부르는 또 다른 트리를 생성한다. 렌더 트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 있는데 정해진 순서대로 화면에 표시된다.
3. 렌더 트리 생성이 끝나면 배치가 시작되는데 이것은 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다.
4. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정이다.

💡 **여기서 DOM이란?**
DOM(Document Object Model, 문서 객체 모델)은 웹 페이지에 대한 인터페이스이다. 기본적으로 여러 프로그램들이 페이지의 콘텐츠 및 구조, 그리고 스타일을 읽고 조작할 수 있도록 API를 제공한다.

💡 **여기서 API란..?**
API(Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

💡 **여기서 노드란?**
노드(node)는 컴퓨터 과학에 쓰이는 기초적인 단위이다.
대형 네트워크에서는 장치나 데이터 지점(data point)를 의미하고, 개인용 컴퓨터, 휴대전화, 프린터와 같은 정보처리 장치들이 노드이다.

일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

### 4.3 동작과정의 예

![webkit-process](https://user-images.githubusercontent.com/65386533/110413439-2e67b200-80d1-11eb-8399-094617ca8b90.png)

▲ 웹킷 렌더링 엔진 동작 과정

![gecko-process](https://user-images.githubusercontent.com/65386533/110413432-2c9dee80-80d1-11eb-955d-451abc68ecae.png)

▲ 게코 렌더링 엔진 동작 과정

웹킷과 게코가 용어를 약간 다르게 사용하고 있지만 동작 과정은 기본적으로 동일하다는 것을 위의 그림을 보면 알 수 있다.

게코는 시각적으로 처리되는 렌더 트리를 "형상 트리(frame tree)"라고 부르고 각 요소를 형상(frame)이라고 하는데 웹킷은 "렌더 객체(render object)"로 구성되어 있는 "렌더 트리(render tree)"라는 용어를 사용한다. 웹킷은 요소를 배치하는데 "배치(layout)"라는 용어를 사용하지만 게코는 "리플로우(reflow)"라고 부른다. "어태치먼트(attachment)"는 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 시각 정보를 연결하는 과정이다. 게코는 HTML과 DOM 트리 사이에 "콘텐츠 싱크(content sink)"라고 부르는 과정을 두는데 이는 DOM 요소를 생성하는 공정으로 웹킷과 비교하여 의미있는 차이점이라고 보지는 않는다.

## 5. 파싱과 DOM 트리 구축

내용이 방대하기 때문에 '브라우저 파싱과 DOM 트리, 렌더 트리'라는 제목으로 따로 다루겠다.

## 6. 렌더 트리 구축

내용이 방대하기 때문에 '브라우저 파싱과 DOM 트리, 렌더 트리'라는 제목으로 따로 다루겠다.

## 7. 배치

렌더러가 생성되어 트리에 추가될 때 크기와 위치 정보는 없는데 이런 값을 계산하는 것을 배치 또는 리플로우(reflow)라고 부른다.

HTML은 흐름 기반의 배치 모델을 사용하는데 이것은 보통 단일 경로를 통해 크기와 위치 정보를 계산할 수 있다는 것을 의미한다. 일반적으로 "흐름 속"에서 나

좌표계는 기준점으로부터 상대적으로 위치를 결정하는데 좌단(X축)과 상단(Y축) 좌표를 사용한다.

배치는 반복되며 HTML 문서의 `<html>` 요소에 해당하는 최상위 렌더러에서 시작한다. 배치는 프레임 계층의 일부 또는 전부를 통해 반복되고 각 렌더러에 필요한 크기와 위치 정보를 계산한다.

최상위 렌더러의 위치는 0,0이고 브라우저 창의 보이는 영역에 해당하는 뷰포트 만큼의 면적을 갖는다.

모든 렌더러는 "배치" 또는 "리플로" 메서드를 갖는데 각 렌더러는 배치해야할 자식의 배치 메소드를 불러온다.

### 7.1 더티 비트 체제

소소한 변경 때문에 전체를 다시 배치하지 않기 위해 브라우저는 "더티 비트" 체제를 사용한다. 렌더러는 다시 배치할 필요가 있는 변경 요소 또는 추가된 것과 그 자식을 "더티"라고 표시한다.

"더티"와 "자식이 더티" 이렇게 두 가지 플래그가 있다. 자식이 더티하다는 것은 본인은 괜찮지만 자식 가운데 적어도 하나를 다시 배치할 필요가 있다는 의미이다.

### 7.2 전역 배치와 점증 배치

배치는 렌더러 트리 전체에서 일어날 수 있는데 이것을 "전역" 배치라 하고 다음과 같은 경우에 발생한다.

1. 글꼴 크기 변경과 같이 모든 렌더러에 영향을 주는 전역 스타일 변경.
2. 화면 크기 변경에 의한 결과

배치는 더티 렌더러가 배치되는 경우에만 점증되는데 추가적인 배치가 필요하기 때문에 약간의 손실이 발생할 수 있다.

점증 배치는 렌더러가 더티일 때 비동기적으로 일어난다. 예를 들면 네트워크로부터 추가 내용을 받아서 DOM 트리에 더해진 다음 새로운 렌더러가 렌더 트리에 붙을 때이다.

💡 **여기서 비동기란?**
비동기(Asynchronous)는 동시에 일어나지 않는다는 뜻이다.

### 7.3 비동기 배치와 동기 배치

점증 배치는 비동기로 실행된다. 파이어폭스는 점증 배치를 위해 "리플로 명령"을 쌓아 놓고 스케줄러는 이 명령을 한꺼번에 실행한다. 웹킷도 점증 배치를 실행하는 타이머가 있는데 트리를 탐색하여 "더티" 렌더러를 배치한다.

"offsetHeight" 같은 스타일 정보를 요청하는 스크립트는 동기적으로 점증 배치를 실행한다.

전역 배치는 보통 동기적으로 실행된다.

때때로 배치는 스크롤 위치 변화와 같은 일부 속성들 때문에 초기 배치 이후 콜백으로 실행된다.

### 7.4 최적화

배치가 "크기 변경" 또는 렌더러 위치 변화 떄문에 실행되는 경우 렌더러의 크기는 다시 계산하지 않고 캐시로부터 가져온다.

어떤 경우는 하위 트리만 수정이 되고 최상위로부터 배치가 시작되지 않는 경우도 있다. 이런 경우는 입력 필드에 텍스트를 입력하는 경우와 같이 변화 범위가 한정적이어서 주변에 영향을 미치지 않을 때 발생한다. 만약 입력 필드 바깥쪽에 텍스트를 입력하는 경우라면 배치는 최상단으로부터 시작될 것이다.

### 7.5 배치 과정

배치는 보통 다음과 같은 형태로 진행된다.

1. 부모 렌더러가 자신의 너비를 결정.
2. 부모가 자식을 검토.
1. 자식 렌더러를 배치(자식의 x와 y를 설정)
2. (부모와 자식이 더티하거나 전역 배치 상태이거나 또는 다른 이유로) 필요하다면 자식 배치를 호출하여 자식의 높이를 계산한다.
3. 부모는 자식의 누적된 높이와 여백, 패딩을 사용하여 자신의 높이를 설정한다. 이 값은 부모 렌더러의 부모가 사용하레 된다.
4. 더티 비트 플래그를 제거한다.

파이어폭스는 "상태" 객체(nsHTMLReflowState)를 배치("리플로"를 의미)를 위한 매개 변수로 사용하는데 상태는 부모의 너비를 포함한다.

파이어폭스 배치의 결과는 "매트릭스" 객체(nsHTMLReflowMatrics)인데 높이가 계산된 렌더러를 포함한다.

### 7.6 너비 계산

렌더러의 너비는 포함하는 블록의 너비, 그리고 렌더러의 너비와 여백, 테두리를 이요하여 계산된다.

예를 들어 다음 `div` 요소의 너비를 보자.

```html
<div style="width: 30%"></div>
```

웹킷은 다음(RenderBox 클래스의 calcWidth 메서드)과 같이 계산할 것이다.

- 컨테이너의 너비는 컨테이너 availableWitdh와 0 사이의 최대값이다. 이 경우 availableWidth는 다음과 같이 계산된 contentWidth이다.
clientWidth() - paddingLeft() - paddingRight()
clientWidth와 clientHeight는 객체의 테두리와 스크롤바를 제외한 내부 영역을 의미한다.
- 요소의 너비는 "width" 스타일 속성의 값이다. 이 컨테이너의 너비의 백분률 값은 절대 값으로 변환될 것이다.
- 좌우측 테두리와 패딩 값이 추가된다.

여기까지 "미리 획득한 너비"의 계산이었다. 이제는 최소 너비와 최대 너비를 계산해야 한다.

미리 획득한 너비가 최대 너비보다 크면 최대 너비가 사용된다. 미리 획득한 너비가 최소 너비(깨지지 않는 가장 작은 단위)보다 작으면 최소 너비가 사용된다.

배치할 필요가 있지만 너비가 고정된 경우 값은 캐시에 저장된다.

### 7.7 줄 바꿈

렌더러가 배치되는 동안 줄을 바꿀 필요가 있을 때 배치는 중단되고 줄 바꿀 필요가 있음을 부모에게 전달한다. 부모는 추가 렌더러를 생성하고 배치를 호출한다.

## 8. 그리기

그리기 단계에서는 화면에 내용을 표시하기 위한 렌더 트리가 탐색되고 렌더러의 "paint" 메서드가 호출된다. 그리기는 UI 기반의 구성 요소를 사용한다.

### 8.1 전역과 검증

그리기는 배치와 마찬가지로 전역 또는 점증 방식으로 수행된다. 점증 그리기에서 일부 렌더러는 전체 트리에 영향을 주지 않는 방식으로 변경된다. 변경된 렌더러는 화면 위의 사각형을 무효화하는데 OS는 이것을 "더티 영역"으로 보고 "paint" 이벤트를 발생시킨다. OS는 몇 개의 영역을 하나로 합치는 방법으로 효과적으로 처리한다. 크롬은 렌더러가 별도의 처리 과정이기 때문에 조금 더 복잡하다. 크롬은 OS의 동작을 어느 정도 모방한다. 프레젠테이션은 이런 이벤트에 귀 기울이고 렌더 최상위로 메세지를 전달한다. 그러면 트리는 적절한 렌더러에 이를 때까지 탐색되고 스스로(보통 자식과 함께) 다시 그려진다.

### 8.2 그리기 순서

CSS 2는 그리기 과정의 순서를 정의했다. 이것은 실제로 요소가 stacking contexts에 쌓이는 순서다. 스택은 뒤에서 앞으로 그려지기 때문에 이 순서는 그리기에 영향을 미친다. 블록 렌더러가 쌓이느 순서는 다음과 같다.

1. 배경 색
2. 배경 이미지
3. 테두리
4. 자식
5. 아웃라인

### 8.3 파이어폭스 표시 목록

파이어폭스는 렌더 트리를 검토하고 그려진 사각형을 위한 표시 목록을 구성한다. 목록은 올바른 그리기 순서(배경, 테두리, 기타...)에 따라 사각형을 위한 적절한 렌더러를 포함한다. 이런 방법으로 트리는 여러 번 리페인팅을 실행하는 대신 한 번만 탐색하면서 배경 색, 배경 이미지, 테두리 그리고 나머지 순으로 그려낸다.

파이어폭스는 다른 불투명 요소 뒤에 완전히 가려진 요소는 추가하지 않는 방법으로 최적화를 진행한다.

### 8.4 웹킷 사각형 저장소

리페인팅 전에 웹킷은 기존의 사각형을 비트맵으로 저장하여 새로운 사각형과 비교하고 차이가 있는 부분만 다시 그린다.

## 9. 동적 변경

브라우저는 변경에 대해 가능한 한 최소한의 동작으로 반응하려고 노력한다. 그렇기 때문에 요소의 색깔이 바뀌면 해당 요소의 리페인팅만 발생한다. 요소의 위치가 바뀌면 요소와 자식 그리고 형제의 리페인팅과 재배치가 발생한다. DOM 노드를 추가하면 노드의 리페인팅과 재 배치가 발생한다. `html` 요소의 글꼴 크기를 변경하는 것과 같은 큰 변경은 캐시를 무효화하고 트리 전체의 배치와 리페인팅이 발생한다.

## 10. 렌더링 엔진의 스레드

렌더링 엔진은 통신을 제외한 거의 모든 경우에 단일 스레드로 동작한다. 파이어폭스와 사파리의 경우 렌더링 엔진의 스레드는 브라우저의 주요한 스레드에 해당한다. 크롬에서는 이것이 탭 프로세스의 주요 스레드이다.

통신은 몇 개의 병렬 스레드에 의해 진행될 수 있는데 병렬 연결의 수는 보통 2개에서 6개로 제한된다(예를 들면 파이어폭스 3은 6개를 사용).

### 10.1 이벤트 순환

브라우저의 주요 스레드는 이벤트 순환으로 처리 과정을 유지하기 위해 무한 순환된다. 배치와 그리기 같은 이벤트를 위해 대기하고 이벤트를 처리한다. 아래는 주요 이벤트 순환을 위한 파이어폭스 코드이다.

```jsx
while (!mExiting)
NS_ProcessNextEvent(thread);
```

## 11. CSS2의 시각 모델

### 11.1 캔버스

CSS2 명세는 캔버스를 "서식 구조가 표현되는 공간"이라고 설명한다. 브라우저가 내용을 그리는 공간인 것이다. 캔버스 공간 각각의 면적은 무한하지만 브라우저는 뷰포트의 크기를 기초로 초기 너비를 결정한다.

CSS2 명세에 따르면 캔버스는 기본적으로 투명하기 때문에 다른 캔버스와 겹치는 경우 비쳐 보이고, 투명하지 않은 경우에는 브라우저에서 정의한 색이 지정된다.

### 11.2 CSS 박스 모델

CSS 박스 모델은 문서 트리에 있는 요소를 위해 생성되고 시각적 서식 모델에 따라 배치된 사각형 박스를 설명한다.

각 박스는 콘텐츠 영역(문자, 이미지 등)과 선택적인 패딩과 테두리, 여백이 있다.

![css-box-model](https://user-images.githubusercontent.com/65386533/110413429-2c055800-80d1-11eb-8ac5-141ddeab728d.png)

▲ CSS2 박스 모델

각 노드는 이런 상자를 0에서 n개 생성한다.

모든 요소는 만들어질 박스의 유형을 결정하는 "display" 속성을 갖는데 이 속성의 유형은 다음과 같다.

- block : 블록 상자를 만든다.
- inline : 하나 또는 그 이상의 인라인 상자를 만든다.
- none : 박스를 만들지 않는다.

기본 값은 인라인이지만 브라우저의 스타일 시트는 다른 기본 값을 설정한다. 예를 들면 `div` 요소의 display 속성에 대한 기본 값은 block이다.

### 11.3 위치 결정 방법

위치를 결정하는 방법은 다음과 같은 세 가지다.

1. Normal : 객체는 문서 안의 자리에 따라 위치가 결정된다. 이것은 렌더 트리에서 객체의 자리가 DOM 트리의 자리와 같고 박스 유형과 면적에 따라 배치됨을 의미한다.
2. Float : 객체는 우선 일반적인 흐름에 따라 배치된 다음 왼쪽이나 오른쪽으로 흘러 이동한다.
3. Absolute : 객체는 DOM 트리 자리와는 다른 렌더 트리에 놓인다.

 위치는 "position"과 "float" 속성에 의해 결정된다.

- static과 relative로 설정하면 일반적인 흐름에 따라 위치가 결정된다.
- absolute와 fixed로 설정하면 절대적인 위치가 된다.

position 속성을 정의하지 않으면 static이 기본 값이 되며 일반적인 흐름에 따라 위치가 결정된다. static이 아닌 다른 속성 값(relative, absolute, fixed)을 사용하면 top, bottom, left, right 속성으로 위치를 결정할 수 있다.

박스가 배치되는 방법은 다음과 같은 방법으로 결정된다.

- 박스 유형(display, inline ...)
- 박스 크기(width, height ...)
- 위치 결정 방법(position, float)
- 추가적인 정보 : 이미지 크기와 화면 크기 등

### 11.4 박스 유형

![box-block](https://user-images.githubusercontent.com/65386533/110413418-29a2fe00-80d1-11eb-86e9-3588756b3550.png)

▲ 블록 박스

- 블록 박스 : 브라우저 창에서 사각형 블록을 형성한다.

![box-inline](https://user-images.githubusercontent.com/65386533/110413423-2ad42b00-80d1-11eb-9f6a-f8a566974e10.png)

▲ 인라인 박스

- 인라인 박스 : 블록이 되지 않고 블록 내부에 포함된다.

![box-block-inline](https://user-images.githubusercontent.com/65386533/110413421-2a3b9480-80d1-11eb-82cd-0a631ae98bb2.png)

▲ 블록과 인라인 배치

블록은 다른 블록 아래 수직으로 배치되고 인라인은 수평으로 배치된다.

![box-line](https://user-images.githubusercontent.com/65386533/110413425-2b6cc180-80d1-11eb-8ef2-bb7d4b90f6cf.png)

▲ 라인

인라인 박스는 라인 또는 "라인 박스" 안쪽에 놓인다. 라인은 적어도 가장 큰 박스만큼 크지만 "baseline" 정렬일 때 더 커질 수 있다. 이것은 요소의 하단이 다른 상자의 하단이 아닌 곳에 배치된 경우를 의미한다. 포함하는 너비가 충분하지 않으면 인라인은 몇 줄의 라인으로 배치되는데 이것은 보통 문단 안에서 발생한다.

### 11.5 위치 잡기

#### 11.5.1 상대적인 위치`position:relative`

상대적인 위치 잡기는 일반적인 흐름에 따라 위치를 결정한 다음 필요한 만큼 이동한다.

HTML을 다음과 같이 작성하면,

```html
<html>
	<div>
		<span>1</span>
		<span>2</span>
		<span style="position:relative;left:5px">3</span>
	</div>
</html>
```

아래와 같이 보일 것이다.

![position-relative](https://user-images.githubusercontent.com/65386533/110413437-2dcf1b80-80d1-11eb-9fdc-14595286ee71.png)

▲ 상대적인 위치 잡기

#### 11.5.2 플로트 `float:left`  `float:right`

플로트 박스는 라인의 왼쪽 또는 오른쪽으로 이동한다. 흥미로운 점은 다른 박스가 이 주변을 흐른다는 것이다.

HTML을 다음과 같이 작성하면,

```html
<p>  
  <img src="http://helloworld.naver.com/image.gif" alt="image.gif" width="100" height="100" style="float:right">  
  Lorem ipsum dolor sit amet, consectetuer...  
</p>
```

아래와 같이 보일 것이다.

![float](https://user-images.githubusercontent.com/65386533/110413430-2c055800-80d1-11eb-8ac1-a71af4d817a4.png)

▲ 플로트

#### 11.5.3 절대적인(absolute) 위치와 고정된(fixed) 위치

절대와 고정 배치는 일반적인 흐름과 무관하게 결정되고, 일반적인 흐름에 관여하지 않으며, 면적은 부모에 따라 상대적이다. 고정인 경우 뷰포트로부터 위치를 결정한다.

HTML을 다음과 같이 작성하면,

```html
<html>
	<div>
		<span>1</span>
		<span>2</span>
		<span style="position:fixed;top:5px;left:5px">3</span>
	</div>
</html>
```

아래와 같이 보일 것이다.

![position-fixed](https://user-images.githubusercontent.com/65386533/110413436-2d368500-80d1-11eb-814c-542869fa4f8c.png)

▲ 고정된 위치 잡기

참고로, 고정된 박스는 문서가 스크롤 되어도 따라 움직이지 않는다.

### 11.6 층 표현

이것은 CSS의 `z-index` 속성에 의해 명시된다. 층은 박스의 3차원 표현이고, "z축"을 따라 위치를 정한다.

박스는 (stacking context라고 부르는) 스택으로 구분된다. 각 스택에서 뒤쪽 요소가 먼저 그려지고 앞쪽 요소는 사용자에게 가까운 쪽으로 나중에 그려진다. 가장 앞쪽에 위치한 요소는 겹치는 이전 요소를 가린다.

스택은 `z-index` 속성에 따라 순서를 결정한다. `z-index` 속성이 있는 박스는 지역 스택(local stack)을 형성한다. 뷰포트는 바깥쪽의 스택(outer stack)이다.

아래 코드는,

```html
<style type="text/css">  
div {  
    position: absolute;
    left: 2in;
    top: 2in;
}
</style>  
<p>  
    <div style="z-index:3;background-color:red;width:1in;height:1in"></div>
    <div style="z-index:1;background-color:green;width:2in;height:2in"></div>
</p>
```

다음과 같이 보일 것이다.

![z-index](https://user-images.githubusercontent.com/65386533/110413440-2e67b200-80d1-11eb-8453-4bdf5758a15d.png)

▲ z-index 위치 잡기

붉은색 박스가 초록색 박스보다 마크업에서 먼저 나오기 때문에 일반적인 흐름이라면 먼저 그려져야 하지만 `z-index` 속성이 높기 때문에 더 앞쪽에 표시된다.

---
# 💡 추가적으로 생각해보기

## **브라우저의 캐시란 무엇이고, 브라우저의 캐시로 인해 css가 반영이 안되는 경우는 어떤 경우이며, 해결방법은 무엇일까?**

### 1. 캐시

#### 1.1 캐시의 정의

흔히 캐싱의 의미는 어떤 것을 나중에 유용하게 사용하기 위해 저장한다는 뜻이다. 브라우저의 캐시도 이와 동일한 뜻이며 추가로 프로그램과 웹사이트의 자산을 저장한다. 웹사이트를 방문했을 때, 클라이언트의 브라우저는 몇 개의 페이지를 갖고 있고 그것을 컴퓨터 하드디스크에 저장한다. 브라우저가 저장할 자산은 아래와 같다.

- 이미지 : 로고, 사진, 백그라운드 등
- HTML
- CSS
- JavaScript

간단히 말해서 브라우저는 정적인 자산(웹페이지에 방문할 때마다 변하지 않는 것들)을 캐시한다.

#### 1.2 캐시의 이점

웹사이트에 처음 방문했을 때, 클라이언트의 브라우저는 원격으로 호스트 사이트 서버와 커뮤니케이션을 한다. 브라우저는 요청하고 서버는 응답을 하면서 웹사이트의 자산을 전달해주는데, HTML이 처음 다운로드 되고 이것이 어떤 사이트를 그려야 하는지에 대한 정보가 담겨있다. 브라우저가 HTML 코드를 읽을 때 서버에게 다른 페이지에 대한 정보를 추가로 요청하는데 대부분 위에서 언급한 정적 자산이다.

이 프로세스는 bandwidth를 사용하는데, 일부 웹페이지는 자산이 방대하기 때문에 모든 페이지를 다운로드하고 기능을 수행하는데 오랜 시간이 걸린다.

그렇기 때문에 캐시가 필요하다. 캐싱은 브라우저 속도를 향상시킨다. 일단 자산을 다운로드하면 하드디스크에 일정 기간동안 존재한다. 인터넷이 아무리 빠르더라도 하드디스크에서 파일을 검색하는 것이 원격으로 서버에 요청하는 것보다 훨씬 효율적이다.

#### 1.3 캐시의 문제점

웹사이트에서 캐싱된 자산을 사용할 수 있도록 허용했다. 

이는 클라이언트 하드디스크엔 이전의 캐시가 존재하므로 예전 버전이 계속 반영되는 것이다. 그러므로 캐시가 만료되지 않는 한 변동사항이 반영될 수 없다.

유저의 하드디스크에 최신버전파일이 캐시되어 있지 않으면 포맷이 안 맞고, 자바스크립트가 깨지고, 올바르지 않은 이미지가 나타나는 등의 에러들이 발생할 수 있다.

그렇기 때문에 대부분의 브라우저는 '캐시 제거'버튼이 있다. 하지만 캐시를 삭제하고 다시 웹사이트를 방문하게 되면 페이지 로딩에 시간이 조금 더 걸린다.

--- 

- 참조

    [https://namu.wiki/w/웹 브라우저](https://namu.wiki/w/%EC%9B%B9%20%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80)

    [https://ko.wikipedia.org/wiki/웹_브라우저](https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80)

    [https://d2.naver.com/helloworld/59361](https://d2.naver.com/helloworld/59361)

    [https://wit.nts-corp.com/2019/02/14/5522](https://wit.nts-corp.com/2019/02/14/5522)

    [https://ko.wikipedia.org/wiki/API](https://ko.wikipedia.org/wiki/API)

    [https://ko.wikipedia.org/wiki/노드_(컴퓨터_과학)](https://ko.wikipedia.org/wiki/%EB%85%B8%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))

    [https://yngmanie.space/posts/cache](https://yngmanie.space/posts/cache)